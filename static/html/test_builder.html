<!DOCTYPE html>
<html>

<head>
  <title>Title of the document</title>
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/style_test_builder.css">
</head>

<body>
  <div id="main_container">
    <div class="box header">
      <span class="header_text">header</span>
    </div>

    <div class="work_container">
      <div class="base_elemnt_holder">

        <div class="dragable_elements_holder">
          <p style="margin: 0px; background-color: azure;">elements</p>
          <div id="one_question_holder_" class="movable question_holder" ondrop="drop_put_to_question(event)"
            ondragover="dragover_handler(event)" draggable="true">
            <p class="element-name" style="margin: 0px; font-family: 'Courier New', Courier, monospace;"></p>
          </div>
          <p id="p1_" class="movable" draggable="true" style="margin: 0px; background-color: aqua;">p1</p>
          <button id="button_" class="movable" draggable="true">base-button</button>

        </div>
        <div class="delete_drop" ondrop="drop_del_handler(event)" ondragover="dragover_handler(event)"> </div>
      </div>

      <div class="drop_receiver" ondrop="drop_put_handler(event)" ondragover="dragover_handler(event)">
        <p style="margin: 0px; background-color: azure;">tests</p>
      </div>
      <div class="element-settings">
        <p style="margin: 0px; background-color: azure;">edit</p>
        <p>element-id <span id="element-id">_</span></p>
      </div>
    </div>

    <div class="footer">
      <span>footer</span>

    </div>

  </div>
  <script>
    const tasksListElement = document.querySelector(`.dragable_elements_holder`);
    const dropReceivers = document.querySelector(`.drop_receiver`);
    const elementSettings = document.querySelector(`.element-settings`);

    let cur_id = 0

    function start_moving(event) {
      if (!event.target.classList || event.target.classList.contains('movable') == false)
        return
      event.dataTransfer.setData("text/plain", event.target.id);
      event.target.classList.add(`selected`);

      unhighlite_selections()
    }
    function stop_moving(event) {
      if (!event.target.classList || event.target.classList.contains('movable') == false)
        return

      const edited_element_id = elementSettings.querySelector('#element-id').textContent
      if (edited_element_id != '') {
        const edited_element = dropReceivers.querySelector(`#${edited_element_id}`)
        if (edited_element) { highlite_selection(edited_element) }
      }

      event.target.classList.remove(`selected`);
    }

    tasksListElement.addEventListener(`dragstart`, start_moving)
    tasksListElement.addEventListener(`dragend`, stop_moving);

    function dragover_handler(ev) {
      ev.preventDefault();
      ev.dataTransfer.dropEffect = "move";
    }
    function RMB_click(event) {
      alert('click')
    }
    function drop_put_to_question(ev) {
      ev.preventDefault();

      if (ev.target.id != ev.currentTarget.id) return
      if (ev.target.id != ev.currentTarget.id) return

      let movable_id = ev.dataTransfer.getData('text')

      const activeElement = document.getElementById(movable_id)
      if (activeElement == null) return

      let newElemnt = activeElement

      if (activeElement.parentNode == tasksListElement) {
        newElemnt = activeElement.cloneNode(true)
        setup_new_element(newElemnt)
      }

      newElemnt.classList.remove('selected')
      try {
        ev.currentTarget.appendChild(newElemnt)
      }
      catch (err) {

      }
    }
    function drop_put_handler(ev) {
      ev.preventDefault();

      if (ev.target != dropReceivers) return

      const movable_id = ev.dataTransfer.getData('text')

      const activeElement = document.getElementById(movable_id)
      if (activeElement == null) return

      let newElemnt = activeElement

      if (activeElement.parentNode == tasksListElement) {
        newElemnt = activeElement.cloneNode(true)
        setup_new_element(newElemnt)
      }
      newElemnt.classList.remove('selected')
      ev.currentTarget.appendChild(newElemnt)
    }

    function drop_del_handler(ev) {
      ev.preventDefault();
      const movable_id = ev.dataTransfer.getData('text')
      const activeElement = dropReceivers.querySelector(`#${movable_id}`)
      activeElement.remove()
    }

    function add_number_to_id(element) {
      element.id += String(cur_id)
      cur_id += 1
    }
    function set_description(element) {
      if (element.classList.contains('question_holder')) {
        element.querySelector('.element-name').textContent = element.id
      }
    }

    function setup_new_element(element) {
      element.addEventListener('dragstart', start_moving)
      element.addEventListener('dragend', stop_moving);
      element.addEventListener('click', one_click)
      add_number_to_id(element)
      set_description(element)
    }

    function one_click(ev) {
      // cur_target - элемент на который кликнули
      const target = ev.target
      const cur_target = ev.currentTarget

      if (target != cur_target && target.classList.contains('movable') == cur_target.classList.contains('movable')) return
      if (target == cur_target || target.parentNode == cur_target) {
        const prev_selected = dropReceivers.querySelector('.selected_for_editing')

        if (prev_selected && prev_selected != cur_target) { prev_selected.classList.remove('selected_for_editing') }

        if (cur_target.classList.contains('selected_for_editing')) {
          unhighlite_selections()
          update_selected_element_info({ id: '' })
        }
        else {
          highlite_selection(cur_target)
          update_selected_element_info(cur_target)
        }
      }
    }

    function unhighlite_selections() {
      const el = dropReceivers.querySelectorAll('.movable')
      el.forEach(element => {
        element.classList.remove('non_selected_for_editing')
        element.classList.remove('selected_for_editing')
      });
    }
    function highlite_selection(element) {
      unhighlite_selections()
      element.classList.add('selected_for_editing')
      element.classList.remove('non_selected_for_editing')

      const el = dropReceivers.querySelectorAll('.movable:not(.selected_for_editing *, .selected_for_editing)')
      el.forEach(element => {
        element.classList.add('non_selected_for_editing')
      });
    }

    function update_selected_element_info(element) {
      const node_element_id = elementSettings.querySelector('#element-id')

      if (!node_element_id || !element) return

      node_element_id.textContent = element.id
    }
  </script>
</body>

</html>